<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.1.0"></script>
<script src="mnist_ui.js"></script>
<style>
  #mnist * { display: block; }
  #mnist canvas { border: 1px solid black; }
</style>

<pre id="status">initializing...</pre>
<div id="mnist"></div>

<script>

const status = document.querySelector('#status')
status.innerText = 'loading model: 0%'

window.onerror = (message, source, lineno, colno, error) =>
  status.innerText = `### JAVASCRIPT ERROR: ${message} at ${source}:${lineno}`;

// Bypass finite-ness checking
const IsFinite = (vec) => {
  return true
  // tf.logicalNot(tf.logicalOr(tf.isNaN(vec), tf.isInf(vec)))
}
tf.registerOp('IsFinite', IsFinite);

const modelDir = 'hamux_model';
tf.loadGraphModel(modelDir + '/model.json', {
    onProgress: p => status.innerText = `loading model: ${Math.round(p*100)}%`
}).then(async model => {
  console.log('loaded', model)
  status.textContent = 'ready!'
  const imgs = tf.ones([784]).cast('float32')
  const logits = tf.zeros([10]).cast('float32')
  const dt = tf.tensor([0.000001]).cast('float32')
  console.log("p5")

  // let outputs = awaijt model.executeAsync(
  //   { 'img_pixels' : imgs, "labels": logits, "dt": dt },
  //   [ 'energy','next_imgs','next_labels']);
  // tf.print(outputs);
  // BREAKS HERE
  const output = model.predict([dt, logits, imgs])
  console.log("p6")
  console.log("OUTPUT")

  // console.log(`Energy: ${energy.dataSync()}`)
  // console.log(`Next imgs: ${newimgs.dataSync()}`)
  // console.log(`Next logits: ${newlogits.dataSync()}`)

  // const ui = mnist_ui(document.querySelector('#mnist'))
  // ui.onUpdate(img => {
  //   const imgs = tf.tensor(img).cast('float32').reshape([1, 28, 28, 1])
  //   const logits = model.predict(imgs)
  //   const preds = tf.softmax(logits)
  //   const { values, indices } = tf.topk(preds, 10)

  //   ui.showPreds([...values.dataSync()], [...indices.dataSync()])
  // })

}).catch(error => {
  status.textContent = 'ERROR : ' + error.message
})
</script>